# Full-Stack Web Application Deployment Guide
# User Management System - FastAPI + React + SQLite

## üì¶ DEPLOYMENT ARTIFACTS

### Backend Artifact (FastAPI)
Location: ./backend/
Main Files:
- main.py (FastAPI application)
- database.py (SQLAlchemy models)
- requirements.txt (Python dependencies)
- db/ (Database files and scripts)
- Dockerfile (Container configuration)
- railway.json (Railway deployment config)
- vercel.json (Vercel deployment config)

### Frontend Artifact (React)
Location: ./frontend/
Main Files:
- src/ (React source code)
- public/ (Static assets)
- package.json (Node.js dependencies)
- build/ (Production build - generated)
- Dockerfile (Container configuration)
- netlify.toml (Netlify deployment config)

## üõ†Ô∏è PRE-DEPLOYMENT SETUP

### 1. Create Production Build Files

#### Backend Requirements File
```bash
cd backend
pip freeze > requirements.txt
```

#### Frontend Production Build
```bash
cd frontend
npm run build
```

### 2. Environment Configuration
Create .env files for different environments:

#### Backend .env
```
DATABASE_URL=sqlite:///./db/user_management.db
SECRET_KEY=your-super-secret-key-here
ENVIRONMENT=production
CORS_ORIGINS=https://your-frontend-domain.com
```

#### Frontend .env
```
REACT_APP_API_URL=https://your-backend-domain.com
REACT_APP_ENVIRONMENT=production
```

## ‚òÅÔ∏è CLOUD DEPLOYMENT OPTIONS

### üöÄ OPTION 1: AWS DEPLOYMENT

#### A. AWS Lambda + S3 (Serverless)

**Backend (AWS Lambda)**
1. Install AWS CLI and configure credentials
2. Install Serverless Framework:
   ```bash
   npm install -g serverless
   npm install -g serverless-python-requirements
   ```
3. Create serverless.yml:
   ```yaml
   service: user-management-api
   provider:
     name: aws
     runtime: python3.9
     region: us-east-1
   functions:
     api:
       handler: main.handler
       events:
         - http:
             path: /{proxy+}
             method: ANY
             cors: true
   plugins:
     - serverless-python-requirements
   ```
4. Deploy:
   ```bash
   serverless deploy
   ```

**Frontend (AWS S3 + CloudFront)**
1. Build React app:
   ```bash
   npm run build
   ```
2. Create S3 bucket and upload build files
3. Configure S3 for static website hosting
4. Set up CloudFront distribution
5. Update DNS records

**Estimated Cost:** $5-20/month depending on usage

#### B. AWS EC2 (Traditional Hosting)

**Backend Setup:**
```bash
# Launch EC2 instance (Ubuntu 20.04)
sudo apt update
sudo apt install python3-pip nginx
pip3 install -r requirements.txt
# Configure nginx reverse proxy
# Set up SSL with Let's Encrypt
```

**Frontend Setup:**
```bash
# Install Node.js
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs
npm install
npm run build
# Configure nginx to serve build files
```

**Estimated Cost:** $10-50/month depending on instance size

### üåê OPTION 2: GOOGLE CLOUD PLATFORM

#### A. Google Cloud Run (Containerized)

**Backend Dockerfile:**
```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 8080
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080"]
```

**Deploy Commands:**
```bash
# Build and push to Google Container Registry
gcloud builds submit --tag gcr.io/PROJECT_ID/user-management-api
# Deploy to Cloud Run
gcloud run deploy --image gcr.io/PROJECT_ID/user-management-api --platform managed
```

**Frontend (Firebase Hosting):**
```bash
npm install -g firebase-tools
firebase login
firebase init hosting
npm run build
firebase deploy
```

**Estimated Cost:** $0-20/month (generous free tier)

#### B. Google App Engine

**app.yaml for Backend:**
```yaml
runtime: python39
service: api
env_variables:
  DATABASE_URL: "sqlite:///./db/user_management.db"
```

**Deploy:**
```bash
gcloud app deploy
```

**Estimated Cost:** $10-30/month

### üéØ OPTION 3: NETLIFY (Frontend) + RAILWAY (Backend)

#### Frontend - Netlify Deployment

**netlify.toml:**
```toml
[build]
  publish = "build"
  command = "npm run build"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

[build.environment]
  REACT_APP_API_URL = "https://your-railway-app.railway.app"
```

**Deploy Steps:**
1. Connect GitHub repository to Netlify
2. Set build command: `npm run build`
3. Set publish directory: `build`
4. Deploy automatically on git push

**Estimated Cost:** Free for personal projects

#### Backend - Railway Deployment

**railway.json:**
```json
{
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "uvicorn main:app --host 0.0.0.0 --port $PORT",
    "healthcheckPath": "/",
    "healthcheckTimeout": 100,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

**Deploy Steps:**
1. Connect GitHub repository to Railway
2. Set environment variables
3. Deploy automatically on git push

**Estimated Cost:** $5/month for hobby plan

### üî• OPTION 4: VERCEL (Full-Stack)

#### Frontend Deployment
**vercel.json:**
```json
{
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "build"
      }
    }
  ],
  "routes": [
    {
      "src": "/(.*)",
      "dest": "/index.html"
    }
  ]
}
```

#### Backend as Serverless Functions
**api/main.py:**
```python
from fastapi import FastAPI
from mangum import Mangum

app = FastAPI()
# Your existing FastAPI code here
handler = Mangum(app)
```

**Deploy:**
```bash
npm install -g vercel
vercel --prod
```

**Estimated Cost:** Free for hobby projects

### üê≥ OPTION 5: DOCKER + DIGITAL OCEAN

#### Backend Dockerfile
```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### Frontend Dockerfile
```dockerfile
FROM node:18-alpine as build

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### Docker Compose for Local Development
```yaml
version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=sqlite:///./db/user_management.db
    volumes:
      - ./backend/db:/app/db

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
```

**Deploy to Digital Ocean:**
1. Create Digital Ocean Droplet
2. Install Docker and Docker Compose
3. Clone repository and run docker-compose up
4. Configure domain and SSL

**Estimated Cost:** $12-50/month depending on droplet size

## üîí SECURITY CONSIDERATIONS

### SSL/TLS Certificate
- Use Let's Encrypt for free SSL certificates
- Configure HTTPS redirects
- Set secure headers

### Environment Variables
- Store sensitive data in environment variables
- Use cloud provider's secret management
- Never commit .env files to version control

### Database Security
- For production, consider PostgreSQL instead of SQLite
- Use connection pooling
- Implement database backups

### CORS Configuration
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://your-frontend-domain.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

## üìä DEPLOYMENT COMPARISON

| Platform | Frontend | Backend | Database | Cost/Month | Complexity |
|----------|----------|---------|----------|------------|------------|
| Netlify + Railway | ‚úÖ | ‚úÖ | SQLite | $5 | Low |
| Vercel | ‚úÖ | ‚úÖ | External DB | $0-20 | Low |
| AWS Lambda + S3 | ‚úÖ | ‚úÖ | RDS | $15-50 | Medium |
| Google Cloud Run | ‚úÖ | ‚úÖ | Cloud SQL | $10-40 | Medium |
| Digital Ocean | ‚úÖ | ‚úÖ | Self-hosted | $12-50 | High |
| AWS EC2 | ‚úÖ | ‚úÖ | Self-hosted | $20-100 | High |

## üöÄ RECOMMENDED DEPLOYMENT STRATEGY

### For Beginners: Netlify + Railway
- **Frontend**: Deploy to Netlify (free)
- **Backend**: Deploy to Railway ($5/month)
- **Total Cost**: $5/month
- **Pros**: Easy setup, automatic deployments, good performance
- **Cons**: SQLite limitations for high traffic

### For Production: AWS or Google Cloud
- **Frontend**: S3 + CloudFront or Firebase Hosting
- **Backend**: Lambda/Cloud Run or EC2/Compute Engine
- **Database**: RDS/Cloud SQL (PostgreSQL)
- **Total Cost**: $20-100/month
- **Pros**: Scalable, enterprise-grade, full control
- **Cons**: More complex setup and management

### For Learning: Digital Ocean Droplet
- **Full Stack**: Docker containers on single droplet
- **Total Cost**: $12/month
- **Pros**: Full control, learning experience
- **Cons**: Manual setup, maintenance required

## üìù DEPLOYMENT CHECKLIST

### Pre-Deployment
- [ ] Create production builds
- [ ] Set up environment variables
- [ ] Configure CORS for production domains
- [ ] Test API endpoints
- [ ] Optimize images and assets
- [ ] Set up error monitoring

### During Deployment
- [ ] Deploy backend first
- [ ] Update frontend API URLs
- [ ] Deploy frontend
- [ ] Configure custom domains
- [ ] Set up SSL certificates
- [ ] Test all functionality

### Post-Deployment
- [ ] Monitor application performance
- [ ] Set up automated backups
- [ ] Configure logging and alerts
- [ ] Document deployment process
- [ ] Plan scaling strategy

## üîÑ CI/CD PIPELINE EXAMPLE (GitHub Actions)

```yaml
name: Deploy Full Stack App

on:
  push:
    branches: [main]

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Deploy to Railway
        uses: railway-app/railway-github-action@v1
        with:
          railway-token: ${{ secrets.RAILWAY_TOKEN }}

  deploy-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build and Deploy to Netlify
        uses: netlify/actions/build@master
        with:
          publish-dir: './frontend/build'
          production-branch: main
```

## üìû SUPPORT AND MONITORING

### Health Checks
- Backend: `/health` endpoint
- Frontend: Service worker for offline detection
- Database: Connection pooling and retry logic

### Logging
- Structured logging with JSON format
- Log aggregation (CloudWatch, Stackdriver)
- Error tracking (Sentry, Rollbar)

### Monitoring
- Uptime monitoring (UptimeRobot, Pingdom)
- Performance monitoring (New Relic, DataDog)
- User analytics (Google Analytics)

---

This deployment guide provides multiple options for hosting your full-stack application. Choose the option that best fits your budget, technical expertise, and scalability requirements.

For immediate deployment, I recommend starting with Netlify (frontend) + Railway (backend) for the easiest setup and lowest cost.
